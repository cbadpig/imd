#### Configuration
The MyBatis configuration contains settings and properties that have a dramatic effect on how MyBatis behaves. The high level structure of the document is as follows:

* configuration
    * properties
    * settings
    * typeAliases
    * typeHandlers
    * objectFactory
    * plugins
    * environments
        * environment
             * transactionManager
             * dataSource
    * databaseIdProvider
    * mappers
#### properties
These are externalizable, substitutable properties that can be configured in a typical Java Properties file instance, or passed in through sub-elements of the properties element. For example:

```
<properties resource="org/mybatis/example/config.properties">
  <property name="username" value="dev_user"/>
  <property name="password" value="F2Fa3!33TYyg"/>
</properties>
``` 
The properties can then be used throughout the configuration files to substitute values that need to be dynamically configured. For example:

```
<dataSource type="POOLED">
  <property name="driver" value="${driver}"/>
  <property name="url" value="${url}"/>
  <property name="username" value="${username}"/>
  <property name="password" value="${password}"/>
</dataSource>
```

The username and password in this example will be replaced by the values set in the properties elements. The driver and url properties would be replaced with values contained from the config.properties file. This provides a lot of options for configuration.

Properties can also be passed into the SqlSessionFactoryBuilder.build() methods. For example:

```
SqlSessionFactory factory =
  sqlSessionFactoryBuilder.build(reader, props);

// ... or ...

SqlSessionFactory factory =
  new SqlSessionFactoryBuilder.build(reader, environment, props);
```

If a property exists in more than one of these places, MyBatis loads them in the following order:
* Properties specified in the body of the properties element are read first,
* Properties loaded from the classpath resource or url attributes of the properties element are read second, and override any duplicate properties already specified,
* Properties passed as a method parameter are read last, and override any duplicate properties that may have been loaded from the properties body and the resource/url attributes.

Thus, the highest priority properties are those passed in as a method parameter, followed by resource/url attributes and finally the properties specified in the body of the properties element.

Since the MyBatis 3.4.2, your can specify a default value into placeholder as follow:

```
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${username:ut_user}"/> <!-- If 'username' property not present, username become 'ut_user' -->
</dataSource>
```

This feature is disabled by default. If you specify a default value into placeholder, you should be enable this feature by adding a special property as follow:

```
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.enable-default-value" value="true"/> <!-- Enable this feature -->
</properties>
```
> NOTE Also If you are used already the `":"` as property key(e.g. `db:username`) or you are used already the ternary operator of OGNL expression(e.g. `${tableName != null ? tableName : 'global_constants'}`) on your sql definition, you should be change the character that separate key and default value by adding a special property as follow:

```
<properties resource="org/mybatis/example/config.properties">
  <!-- ... -->
  <property name="org.apache.ibatis.parsing.PropertyParser.default-value-separator" value="?:"/> <!-- Change default value of separator -->
</properties>
```

```
<dataSource type="POOLED">
  <!-- ... -->
  <property name="username" value="${db:username?:ut_user}"/>
</dataSource>
```

#### settings
These are extremely important tweaks that modify the way that MyBatis behaves at runtime. The following table describes the settings, their meanings and their default values.

Setting|Description|Valid Values|Default
---|---|---|---
cacheEnabled|Globally enables or disables any caches configured in any mapper under this configuration.|true\\false|true
lazyLoadingEnabled|	Globally enables or disables lazy loading. When enabled, all relations will be lazily loaded. This value can be superseded for an specific relation by using the fetchType attribute on it.|true\\false|false
aggressiveLazyLoading|Globally enables or disables lazy loading. When enabled, all relations will be lazily loaded. This value can be superseded for an specific relation by using the fetchType attribute on it.|true\\false|false (true in ≤3.4.1)
multipleResultSetsEnabled|Allows or disallows multiple ResultSets to be returned from a single statement (compatible driver required).|true\\false|true
useColumnLabel|Uses the column label instead of the column name. Different drivers behave differently in this respect. Refer to the driver documentation, or test out both modes to determine how your driver behaves.|true\\false|true
useGeneratedKeys|Allows JDBC support for generated keys. A compatible driver is required. This setting forces generated keys to be used if set to true, as some drivers deny compatibility but still work (e.g. Derby).|true\\false|false
autoMappingBehavior|Specifies if and how MyBatis should automatically map columns to fields/properties. NONE disables auto-mapping. PARTIAL will only auto-map results with no nested result mappings defined inside. FULL will auto-map result mappings of any complexity (containing nested or otherwise).|NONE, PARTIAL, FULL|PARTIAL
autoMappingUnknownColumnBehavior|Specify the behavior when detects an unknown column (or unknown property type) of automatic mapping target. * NONE: Do nothing * WARNING: Output warning log (The log level of 'org.apache.ibatis.session.AutoMappingUnknownColumnBehavior' must be set to WARN) * FAILING: Fail mapping (Throw SqlSessionException)|NONE, WARNING, FAILING|NONE
defaultExecutorType|Configures the default executor. SIMPLE executor does nothing special. REUSE executor reuses prepared statements. BATCH executor reuses statements and batches updates.|SIMPLE REUSE BATCH|SIMPLE
defaultStatementTimeout|Sets the number of seconds the driver will wait for a response from the database.|Any positive integer|Not Set (null)
defaultFetchSize|Sets the driver a hint as to control fetching size for return results. This parameter value can be override by a query setting.|Any positive integer|Not Set (null)
safeRowBoundsEnabled|Allows using RowBounds on nested statements. If allow, set the false.|true\\false|false
safeResultHandlerEnabled|Allows using ResultHandler on nested statements. If allow, set the false.|true\\false|true
mapUnderscoreToCamelCase|Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn.|true\\false|false
localCacheScope|MyBatis uses local cache to prevent circular references and speed up repeated nested queries. By default (SESSION) all queries executed during a session are cached. If localCacheScope=STATEMENT local session will be used just for statement execution, no data will be shared between two different calls to the same SqlSession.|SESSION \\ STATEMENT|SESSION
jdbcTypeForNull|Specifies the JDBC type for null values when no specific JDBC type was provided for the parameter. Some drivers require specifying the column JDBC type but others work with generic values like NULL, VARCHAR or OTHER.|JdbcType enumeration. Most common are: NULL, VARCHAR and OTHER|OTHER
lazyLoadTriggerMethods|Specifies which Object's methods trigger a lazy load|A method name list separated by commas|equals,clone,hashCode,toString
defaultScriptingLanguage|Specifies the language used by default for dynamic SQL generation.|A type alias or fully qualified class name.|org.apache.ibatis.scripting.xmltags.XMLLanguageDriver
defaultEnumTypeHandler|Specifies the TypeHandler used by default for Enum. (Since: 3.4.5)|A type alias or fully qualified class name.|org.apache.ibatis.type.EnumTypeHandler
callSettersOnNulls|Specifies if setters or map's put method will be called when a retrieved value is null. It is useful when you rely on Map.keySet() or null value initialization. Note primitives such as (int,boolean,etc.) will not be set to null.|true\\false|false
returnInstanceForEmptyRow|MyBatis, by default, returns null when all the columns of a returned row are NULL. When this setting is enabled, MyBatis returns an empty instance instead. Note that it is also applied to nested results (i.e. collectioin and association). Since: 3.4.2|true\\false|false
logPrefix|Specifies the prefix string that MyBatis will add to the logger names.|Any String|Not set
logImpl|Specifies which logging implementation MyBatis should use. If this setting is not present logging implementation will be autodiscovered.|SLF4J \\LOG4J \\LOG4J2\\ JDK_LOGGING\\COMMONS_LOGGING \\STDOUT_LOGGING\\NO_LOGGING|Not set
proxyFactory|Specifies the proxy tool that MyBatis will use for creating lazy loading capable objects.|CGLIB | JAVASSIST\\JAVASSIST (MyBatis 3.3 or above)
vfsImpl|Specifies VFS implementations|Fully qualified class names of custom VFS implementation separated by commas.|Not set
useActualParamName|Allow referencing statement parameters by their actual names declared in the method signature. To use this feature, your project must be compiled in Java 8 with -parameters option. (Since: 3.4.1)|true\\false|true
configurationFactory|Specifies the class that provides an instance of Configuration. The returned Configuration instance is used to load lazy properties of deserialized objects. This class must have a method with a signature static Configuration getConfiguration(). (Since: 3.2.3)|A type alias or fully qualified class name.|Not set

An example of the settings element fully configured is as follows:
```
<settings>
  <setting name="cacheEnabled" value="true"/>
  <setting name="lazyLoadingEnabled" value="true"/>
  <setting name="multipleResultSetsEnabled" value="true"/>
  <setting name="useColumnLabel" value="true"/>
  <setting name="useGeneratedKeys" value="false"/>
  <setting name="autoMappingBehavior" value="PARTIAL"/>
  <setting name="autoMappingUnknownColumnBehavior" value="WARNING"/>
  <setting name="defaultExecutorType" value="SIMPLE"/>
  <setting name="defaultStatementTimeout" value="25"/>
  <setting name="defaultFetchSize" value="100"/>
  <setting name="safeRowBoundsEnabled" value="false"/>
  <setting name="mapUnderscoreToCamelCase" value="false"/>
  <setting name="localCacheScope" value="SESSION"/>
  <setting name="jdbcTypeForNull" value="OTHER"/>
  <setting name="lazyLoadTriggerMethods"
    value="equals,clone,hashCode,toString"/>
</settings>
```
#### typeAliases
A type alias is simply a shorter name for a Java type. It's only relevant to the XML configuration and simply exists to reduce redundant typing of fully qualified classnames. For example:

```
<typeAliases>
  <typeAlias alias="Author" type="domain.blog.Author"/>
  <typeAlias alias="Blog" type="domain.blog.Blog"/>
  <typeAlias alias="Comment" type="domain.blog.Comment"/>
  <typeAlias alias="Post" type="domain.blog.Post"/>
  <typeAlias alias="Section" type="domain.blog.Section"/>
  <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
```
With this configuration, Blog can now be used anywhere that domain.blog.Blog could be.

You can also specify a package where MyBatis will search for beans. For example:
```
<typeAliases>
  <package name="domain.blog"/>
</typeAliases>
```
Each bean found in domain.blog , if no annotation is found, will be registered as an alias using uncapitalized non-qualified class name of the bean. That is domain.blog.Author will be registered as author. If the @Alias annotation is found its value will be used as an alias. See the example below:
```
@Alias("author")
public class Author {
    ...
}
```

There are many built-in type aliases for common Java types. They are all case insensitive, note the special handling of primitives due to the overloaded names.

别名| 映射的类型
---|---
_byte|byte
_long|long
_short|short
_int|int
_integer|int
_double|double
_float|float
_boolean|boolean
string|String
byte|Byte
long|Long
short|Short
int|Integer
integer|Integer
double|Double
float|Float
boolean|Boolean
date|Date
decimal|BigDecimal
bigdecimal|BigDecimal
object|Object
map|Map
hashmap|HashMap
list|List
arraylist|ArrayList
collection|Collection
iterator|Iterator
#### typeHandlers
Whenever MyBatis sets a parameter on a PreparedStatement or retrieves a value from a ResultSet, a TypeHandler is used to retrieve the value in a means appropriate to the Java type. The following table describes the default TypeHandlers.

NOTE Since version 3.4.5, The MyBatis has been supported JSR-310(Date and Time API) by default.


You can override the type handlers or create your own to deal with unsupported or non-standard types. To do so, implement the interface org.apache.ibatis.type.TypeHandler or extend the convenience class org.apache.ibatis.type.BaseTypeHandler and optionally map it to a JDBC type. For example:

```
// ExampleTypeHandler.java
@MappedJdbcTypes(JdbcType.VARCHAR)
public class ExampleTypeHandler extends BaseTypeHandler<String> {

  @Override
  public void setNonNullParameter(PreparedStatement ps, int i,
    String parameter, JdbcType jdbcType) throws SQLException {
    ps.setString(i, parameter);
  }

  @Override
  public String getNullableResult(ResultSet rs, String columnName)
    throws SQLException {
    return rs.getString(columnName);
  }

  @Override
  public String getNullableResult(ResultSet rs, int columnIndex)
    throws SQLException {
    return rs.getString(columnIndex);
  }

  @Override
  public String getNullableResult(CallableStatement cs, int columnIndex)
    throws SQLException {
    return cs.getString(columnIndex);
  }
}
```
```
<!-- mybatis-config.xml -->
<typeHandlers>
  <typeHandler handler="org.mybatis.example.ExampleTypeHandler"/>
</typeHandlers>
```

Using such a TypeHandler would override the existing type handler for Java String properties and VARCHAR parameters and results. Note that MyBatis does not introspect upon the database metadata to determine the type, so you must specify that it’s a VARCHAR field in the parameter and result mappings to hook in the correct type handler. This is due to the fact that MyBatis is unaware of the data type until the statement is executed.

MyBatis will know the the Java type that you want to handle with this TypeHandler by introspecting its generic type, but you can override this behavior by two means:
* Adding a javaType attribute to the typeHandler element (for example: javaType="String")
* Adding a @MappedTypes annotation to your TypeHandler class specifying the list of java types to associate it with. This annotation will be ignored if the javaType attribute as also been specified.

Associated JDBC type can be specified by two means:

* Adding a jdbcType attribute to the typeHandler element (for example: jdbcType="VARCHAR").
* Adding a @MappedJdbcTypes annotation to your TypeHandler class specifying the list of JDBC types to associate it with. This annotation will be ignored if the jdbcType attribute as also been specified.

When deciding which TypeHandler to use in a ResultMap, the Java type is known (from the result type), but the JDBC type is unknown. MyBatis therefore uses the combination javaType=[TheJavaType], jdbcType=null to choose a TypeHandler. This means that using a @MappedJdbcTypes annotation restricts the scope of a TypeHandler and makes it unavailable for use in ResultMaps unless explicity set. To make a TypeHandler available for use in a ResultMap, set includeNullJdbcType=true on the @MappedJdbcTypes annotation. Since Mybatis 3.4.0 however, if a single TypeHandler is registered to handle a Java type, it will be used by default in ResultMaps using this Java type (i.e. even without includeNullJdbcType=true).

And finally you can let MyBatis search for your TypeHandlers:























